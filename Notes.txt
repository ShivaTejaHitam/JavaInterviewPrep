				Java Interview Preparation

classes have only two access specifiers public and default(nothing)

Reentrant locks do not allow multiple threads to access the critical section of different objects.
Synchronized is a monitor lock which aquires lock on critical section of single object. Two different threads can access critical section of synchronized method of different objects simultaneously.


what are new features of java 8 ?
lambda expressions, functional interfaces , Optional,  CompletableFuture , default methods ,  new Date and Time API using package java.time




what is yield method ?

Explain garbage collection.

If we return in try block, does finally execute ? yes 

How string immutablility provides thread safety ?

Can we extend interfaces from another interface? 
Yes we can use extend keyword similar to classes

what is Arrays.asList() ?
This method is used to create a fixed size list from an array or elements.





4. Explain LifeCycle of a Bean 
The lifecycle of beans in Spring refers to the various stages a bean goes through from its instantiation to its destruction. Understanding the bean lifecycle is crucial for managing resources, initialization, and cleanup tasks efficiently. The bean lifecycle in Spring typically consists of the following stages:
Bean life cycle is managed by the spring container. When we run the program then, first of all, the spring container gets started. After that, the container creates the instance of a bean as per the request, and then dependencies are injected. And finally, the bean is destroyed when the spring container is closed. Therefore, if we want to execute some code on the bean instantiation and just after closing the spring container, then we can write that code inside the custom init() method and the destroy() method.

To provide the facility to the created bean to invoke custom init() method on the startup of a spring container and to invoke the custom destroy() method on closing the container, we need to implement our bean with two interfaces namely InitializingBean, DisposableBean and will have to override afterPropertiesSet() and destroy() method. afterPropertiesSet() method is invoked as the container starts and the bean is instantiated whereas, the destroy() method is invoked just after the container is closed. 
Note: To invoke destroy method we have to call a close() method of ConfigurableApplicationContext.


// Java program to create a bean
// in the spring framework
package beans;
 
import org.springframework
    .beans.factory.DisposableBean;
 
import org.springframework
    .beans.factory.InitializingBean;
 
// HelloWorld class which implements the
// interfaces
public class HelloWorld
    implements InitializingBean,
 DisposableBean {
 
    @Override
    // It is the init() method
    // of our bean and it gets
    // invoked on bean instantiation
    public void afterPropertiesSet() 
throws Exception
    {
        System.out.println(
            "Bean HelloWorld has been "
            + "instantiated and I'm the "
            + "init() method");
    }
 
    @Override
    // This method is invoked
    // just after the container
    // is closed
    public void destroy() throws Exception
    {
        System.out.println(
            "Container has been closed "
            + "and I'm the destroy() method");
    }
}


•	Now, we need to configure the spring XML file spring.xml and define the bean.
•	XML
 
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
             
<beans>
    <bean id="hw" class="beans.HelloWorld"/>
     
</beans>

Finally, we need to create a driver class to run this bean.
// Java program to call the
// bean initialized above
 
package test;
 
import org.springframework
    .context
    .ConfigurableApplicationContext;
 
import org.springframework
    .context.support
    .ClassPathXmlApplicationContext;
 
import beans.HelloWorld;
 
// Driver class
public class Client {
 
    public static void main(String[] args)
        throws Exception
    {
 
        // Loading the Spring XML configuration
        // file into the spring container and
        // it will create the instance of the bean
        // as it loads into container
        ConfigurableApplicationContext cap
            = new ClassPathXmlApplicationContext(
                "resources/spring.xml");
 
        // It will close the spring container
        // and as a result invokes the
        // destroy() method
        cap.close();
    }
}








9.	Explain Functional Interfaces in java
In java , functional interface is an interface that contains only one abstract method. Functional interfaces are key concept in Java’s support for functional programming, introduced in Java 8. They enable the use of lambda expressions and method references to represent instances of single method interfaces more concisely and effectively.
Here are key points about functional interfaces in Java: 
1.Single Abstract Method(SAM) Interface : A functional Interface must contain exactly one abstract method.It can contain multiple default or static methods, but only one abstract method.This single method represents the behaviour encapsulated by the functional interface.
2.@FunctionalInterface Annotation : 
While it's not strictly required, it's a good practice to annotate functional interfaces with @FunctionalInterface annotation. This annotation ensures that the interface is intended to be used as a functional interface, and the compiler will produce an error if more than one abstract method is added to it.
3.Lambda Expressions and Method References: Functional interfaces are primarily used to represent behaviors as lambda expressions or method references. Instead of creating separate implementations of the interface for each behavior, you can pass lambda expressions or method references that define the behavior directly, making the code more concise and expressive.
4. Built-in Functional Interfaces: Java provides several built-in functional interfaces in the java.util.function package, such as Predicate, Function, Consumer, Supplier, etc. These interfaces cover common functional use cases and can be used directly or extended to create custom functional interfaces.
5.Usage in Streams and APIs : 
Functional Interfaces are used extensively in Java Stream Api and other APIs introduced in Java 8 and later. They allow for a more functional style of programming, where operations like mapping, filtering, and reducing can be performed concisely using lambda expressions.

Example : 
@FunctionalInterface
interface Printer{
	   void printMessage(String message);
}

class Main{
	   public static void main(String[] args){
        Printer printer = (String msg) -> System.out.println(msg);
	      printer.printMessage(“Hello”);
  }
}

10.	Explain Inbuilt Functional Interfaces in Java .
In java, the java.util.function package provides a set of  built-in functional interfaces that represent common function types. These interfaces are widely used in stream API and many other cases of functional programming.

Here are few built-in functional interfaces in java :

•	Predicate<T> : Represents a predicate(Boolean valued function) of one argument. It is commonly used to filter elements in collections or streams
Example : 
Predicate<Integer> evenChecker = n -> n % 2 == 0;
System.out.println(evenChecker.test(10));
•	Function<T, R>: Represents a function that accepts one argument and produces a result. It's commonly used for mapping or transforming elements.
Example : 
Function<String,Integer> findStringLength = str -> str.length();
System.out.println(findStringLength.apply(“Shiva”));
•	Consumer<T> : Represents an operation that accepts a single input argument and returns no result. It's often used for consuming or processing elements.
Example: 
Consumer<String> welcomeGreeter = str -> System.out.println(“Welcome “+str);
System.out.println(welcomeGreeter.accept(“Shiva Teja”));
•	Supplier<T>: Represents a supplier of results. It has no input arguments and produces a result. It's commonly used for lazy initialization or generating values.
Example:
Supplier<Double> randomDouble = () -> Math.random();
System.out.println(randomDouble.get());
•	UnaryOperator<T>: Represents an operation on a single operand that produces a result of the same type as its operand. It's often used for unary operations.
Example:
UnaryOperator<Integer> square = n -> n *n;
System.out.prinltn(square.apply(2));
•	BinaryOperator<T> : Represents an operation on two operands of same type and produces a result of same type. 
Example
BinaryOperator<Integer,Integer> multipler = (n,m) -> n *m ;
System.out.println(multipler.apply(2,4));

11.Explain Stream API in java 8
In java, the stream API was introduced in java 8 as new abstraction that allows developers to process collections of data in functional and declarative manner. It provides a set of methods to perform operations on sequences of elements, such as filtering, mapping, sorting, and reducing. Streams allow for concise and expressive code, promoting readability and maintainability.
Here's an overview of some key concepts and functionalities of the Stream API:
1.Stream Creation : Stream can be created from various data sources such as collections,arrays, or even I/O operations.They can also be generated using static factory methods provided by stream interface.
List<Integer> numbers = Arrays.asList(1,2,3,4,5);
Stream<Integer> stream = numbers.stream();
2.Intermediate Operations :
These operations are applied to stream and return another stream. Intermediate operations include filtering, mapping, sorting etc. These operations are lazy, meaning they do not perform any processing until the terminal operation is invoked.
Stream<Integer> filteredStream = numbers.stream().filter(n -> n % 2==0);
Stream<Integer> mappedStream = numbers.stream().map(n-> n+1);
3.Terminal Operations : 
These operations consume the stream and produce a result. Terminal operations include reduction operations like reduce, collect, and forEach, as well as operations to find elements like findFirst, findAny, and count.
int sum = numbers.stream().reduce((a,b)-> a+b);
List<Integer> evenNumbers = numbers.stream().filter(n -> n%2==0).collect(Collectors.toList());

4.Parallel Streams : 
Streams can be processed sequentially or parallel.Parallel streams automatically divide the workload across multiple threads, which can lead to improved performance for large datasets.
Example: 
List<Integer> evenNumbers = numbers.parallelStream().filter(n -> n % 2 ==0).collect(Collectors.toList());

5.Lazy Evaluation : 
Intermediate operations are lazily evaluated, meaning they are only executed only when a terminal operation is invoked.This allows for efficient processing of large datasets because unnecessary computations are avoided.
List<String> strings = Arrays.asList(“abc”,”efg”,”hij”);
Stream<String> filteredStrings = strings.stream().filter(s -> { 
System.out.println(“Filtering” +s);
return s.contains(“a”);
});

filteredStrings.forEach(System.out::println); // without this statement nothing is printed


12.Explain difference between map and flatMap.
map and flatMap are higher order functions used in java.

map : 
The map function takes each element of a collection and applies a function to it, returning a new collection of same size where each element is the result of applying the function to the corresponding element in the original collection.

flatMap :

•	The flatMap function is similar to map, but it’s used when mapping function returns a collection itself.It then flattens these nested collections in to a single collection.
•	It first applies the transformation function to each element of the collection, resulting in a collection of collections.Then it flattens this collection of collections in to a single collection.
•	flatMap is often used when you want to perform a one-to-many transformation and then flatten the result.
public class Main {
    public static void main(String[] args) {
        List<List<Integer>> nestedList = Arrays.asList(
                Arrays.asList(1, 2, 3),
                Arrays.asList(4, 5, 6),
                Arrays.asList(7, 8, 9)
        );

        // Using flatMap to flatten the nested lists
        List<Integer> flattenedList = nestedList.stream()
                                                .flatMap(List::stream)
                                                .collect(Collectors.toList());

        System.out.println(flattenedList); // Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
    }
}

In this example : 
•	We have a nested list of integers (nestedList) , where each element is a list of integers.
•	We use the flatMap operation to transform each nested list in to a stream of its elements.
•	The resulting stream is a single stream containing all the elements from the nested lists.
•	Finally, we collect the elements of the flattened stream in to a list.



13.Explain method reference and constructor reference in java.

14.Explain Comparator and Comparable in java
In Java, ‘Comparator’ and ‘Comparable’ are interfaces used for sorting and ordering objects in collections.They both serve the similar purpose but differ in implementation and usage scenarios.
1.Comparable
•	Comparable is an interface that allows objects to be compared to each other for the purpose of natural ordering.
•	It is used to define default sorting behaviour of objects of class.
•	The compareTo method is implemented in the class whose objects need to be sorted.
•	This interface is typically implemented by the class of objects that need to be sorted.
import java.util.*;

class Student implements Comparable<Student> {
    private int id;
    private String name;

    // Constructor, getters, setters...

    @Override
    public int compareTo(Student otherStudent) {
        // Compare based on student names
        return this.name.compareTo(otherStudent.getName());
    }
}

public class ComparableExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(101, "Alice"));
        students.add(new Student(102, "Bob"));
        students.add(new Student(103, "Charlie"));

        Collections.sort(students);

        for (Student student : students) {
            System.out.println(student.getName());
        }
    }
}
2.Comparator
•	Comparator is an interface that provides a way to sort objects based on different criteria.
•	It allows the definition of custom comparison logic separate from the class whose objects are being sorted.
•	It is useful when you want to define multiple sorting criteria or when you cannot modify the class of objects being sorted.
•	The  compare method is used to compare two objects.
•	
Usage:
import java.util.*;

class Student {
    private int id;
    private String name;

    // Constructor, getters, setters...

    // Static inner class implementing Comparator
    static class NameComparator implements Comparator<Student> {
        @Override
        public int compare(Student student1, Student student2) {
            // Compare based on student names
            return student1.getName().compare(student2.getName());
        }
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(101, "Alice"));
        students.add(new Student(102, "Bob"));
        students.add(new Student(103, "Charlie"));

        // Create a Comparator object
        Student.NameComparator nameComparator = new Student.NameComparator();

        // Sort the list using the Comparator
        students.sort(nameComparator);

        for (Student student : students) {
            System.out.println(student.getName());
        }
    }
}
•	For Comparable, sorting is done using Arrays.sort() or Collections.sort(), where the objects themselves define the sorting logic.
•	For Comparator, sorting can be done using overloaded versions of sort() method or using classes like TreeSet and TreeMap, where the sorting logic is provided externally through a Comparator object.

15.Explain volatile and transient keyword in java

Volatile: 
•	The volatile keyword is used to indicate that a variable’s value may be modified by multiple threads that are executing concurrently.When a variable is declared as volatile, it guarantees visibility of changes made to the variable across threads.
•	Essentially , when a variable is declared as volatile, any read or write operation on that variable will be performed directly on the main memory rather than in thread’s cache.This ensures that changes made by one thread to a volatile variable are immediately visible to other threads.
•	However volatile does not provide atomicity or synchronization . It only ensures visibility. 
Code Snippet: 
Suppose we have a boolean flag variable shared among multiple threads, and one thread modifies the flag while other threads read it. We want to ensure that changes to the flag made by one thread are immediately visible to other threads.
 class SharedResource {
    private volatile boolean flag = false;

    public void setFlag(boolean value) {
        flag = value;
    }

    public boolean getFlag() {
        return flag;
    }
}

In this example, the volatile keyword is used for the flag variable. Now, any changes made to flag by one thread will be immediately visible to other threads.
public class Main {
    public static void main(String[] args) {
        SharedResource sharedResource = new SharedResource();

        // Thread 1 - sets the flag
        new Thread(() -> {
            sharedResource.setFlag(true);
        }).start();

        // Thread 2 - reads the flag
        new Thread(() -> {
            System.out.println("Flag value: " + sharedResource.getFlag());
        }).start();
    }
}

Transient: 
•	The transient keyword is used to indicate that a variable should not be serialized when the object is serialized. In Java, serialization is the process of converting an object into a byte stream, which can then be saved to a file or sent over a network.
•	When an object is serialized , all of its non-transient fields are written to output stream.However,if field is marked as transient , its value will not be persisted during serialization. When the object is deserialized,the transient variable will be initialized to its default value(eg: null for object references and , 0 for primitive values).
•	  The transient keyword is often used for fields that hold temporary or derived data, or for fields that should not be serialized due to security or performance reasons.
•	Code snippet 
import java.io.Serializable;
import java.io.*;


public class Person implements Serializable {
    private String name;
    private transient String ssn;

    public Person(String name, String ssn) {
        this.name = name;
        this.ssn = ssn;
    }

    public String getName() {
        return name;
    }

    public String getSsn() {
        return ssn;
    }
}


public class SerializationExample {
    public static void main(String[] args) {
        Person person = new Person("John Doe", "123-45-6789");

        // Serialize the object
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.ser"))) {
            oos.writeObject(person);
            System.out.println("Object has been serialized");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Deserialize the object
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.ser"))) {
            Person deserializedPerson = (Person) ois.readObject();
            System.out.println("Deserialized Person: " + deserializedPerson.getName());
            System.out.println("Deserialized SSN: " + deserializedPerson.getSsn());
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

16) Why String is immutable ? 
  String is often used as database passwords and usernames etc. So it needs to be immutable to prevent modification .
  It saves lot of space in string pool of heap by avoiding duplicate creation
  It can be safely used in multithreaded environments.

18) What are JAR and WAR files ? what are difference between JAR and WAR ?
JAR - It is a compressed archive of .class files . They are used to distribute java libraries, java application
WAR - Compressed archive of a web application, They are used to distribure web application

20) What are features of Java 17 ? sealed class 
21) Can we override static methods in Java ? No. 
22) Why String is immutable ? 
  String is often used as database passwords and usernames etc. So it needs to be immutable to prevent modification .
  It saves lot of space in string pool of heap by avoiding duplicate creation
  It can be safely used in multithreaded environments.
23) What is the use of default methods in interfaces ? what is the signature of default methods.
24) Does abstract class have constructor ? yes







32) What is the difference between Stream.of and Arrays.stream in java ?
	Stream.of() creates entire object as stream if array is passed
	Arrays.stream() treats elements of array as individual elements of stream

38) what are different ways to achieve synchronization in java
39) Explain how abstract class is different from interface. When to use what ?
interfaces :
	- meant to define a contract that classes can implement. 
	- multiple inheritence
	- no state . since there are no instance variables. 
	- no constructor since there is no state to initialize.
abstract class :
	- They provide base class with some behaviour. They are used to share code between closely related classes
	- have state
	- has constructor which can be called when  subclass is initialized.


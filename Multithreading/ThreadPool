1) Thread Pool is a collection of threads(aka workers) which are available to perform the submitted tasks. 
2) Once task is completed, worker thread goes back to the Thread Pool and wait for new task to be assigned. So that the thread can be reused.
3) Creation of Threads is an overhead like creating space and managing states. Threadpool helps in minimizing this overhead.
4) If more threads are created for each task, the context switching increases because more threads involves more context switching and it is expensive
5) Also thread pool abstract the process of managing  thread lifecycle


Working : 
ThreadPoolExecutor has queue, threadpool .
whenever task comes to the queue , the thread pool picks the task and executes it until the min no of threads in thread pool are utilized
After that the tasks are pushed in to queue. If the thread gets idle it picks the tasks from queue.
If the queue is filled and all minPool threads are busy, for every new task the new thread is created in thread pool until the maxPoolSize is utilized.
After the queue and maxPool size are filled, new tasks are rejected.

Why first we put in to the queue instead of creating new threads ? 
To avoid creating more threads because more threads = more overhead. that is why threads are created only during peak

allowCoreThreadTimeOut - if this property is set to true, idle thread is kept alive until keepAlive time.
arguments expected by ThreadPoolExecutor 
- corePoolSize - the minimum number of threads should be available in threadpool always 
- maxPoolSize - the maximum number of threads allowed in thread pool
- keepAliveTime- idle threads are terminated after this much time
- TimeUnit - unit for keepAliveTime
- workQueue(blockingQueue) - queue used to hold tasks before they are picked up by the worker threads


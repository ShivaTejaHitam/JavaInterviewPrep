1) Thread Pool is a collection of threads(aka workers) which are available to perform the submitted tasks. 
2) Once task is completed, worker thread goes back to the Thread Pool and wait for new task to be assigned. So that the thread can be reused.
3) Creation of Threads is an overhead like creating space and managing states. Threadpool helps in minimizing this overhead.
4) If more threads are created for each task, the context switching increases because more threads involves more context switching and it is expensive
5) Also thread pool abstract the process of managing  thread lifecycle


Working : 
ThreadPoolExecutor has queue, threadpool .
whenever task comes to the queue , the thread pool picks the task and executes it until the min no of threads in thread pool are utilized
After that the tasks are pushed in to queue. If the thread gets idle it picks the tasks from queue.
If the queue is filled and all minPool threads are busy, for every new task the new thread is created in thread pool until the maxPoolSize is utilized.
After the queue and maxPool size are filled, new tasks are rejected.

Why first we put in to the queue instead of creating new threads ? 
To avoid creating more threads because more threads = more overhead. that is why threads are created only during peak

allowCoreThreadTimeOut - if this property is set to true, idle thread is kept alive until keepAlive time.
arguments expected by ThreadPoolExecutor 
- corePoolSize - the minimum number of threads should be available in threadpool always 
- maxPoolSize - the maximum number of threads allowed in thread pool
- keepAliveTime- idle threads are terminated after this much time
- TimeUnit - unit for keepAliveTime
- workQueue(blockingQueue) - queue used to hold tasks before they are picked up by the worker threads
- threadFeactory - interface used by threadPoolExecutor to create new threads. It provides options for customThreadName, priority, setDeamon etc
- RejectedExecutionHanlder - used to provide handlers to execute rejected tasks



Life Cycle of ThreadPoolExecutor
- Running - can accept new tasks
- shutDown() -> Shutdown - won't accept new tasks, but continue already in progress tasks
- shutDownNow()-> Stop - won't accept new tasks and also stop currently running tasks
- Terminated -> All threads are eliminated

How do you choose minPoolSize, maxPoolSize and queueSize ? 
It depends on several factors 
 - CPU core size if you create more threads than no of cores, most of the time goes in context switching
 - JVM memory - If there is no enough memory, high no of cores do not help. 
 - nature of task - more threads for IO intensive and less for CPU intensive
 - concurrency requirement
 - memory demanded by request or task
 - Throughput required 

Formula for approx no of threads required
No of threads = No of Cores * (1 + request waiting time / processing time)
